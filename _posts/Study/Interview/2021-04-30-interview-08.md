---
title:  "[기술면접] 동기와 비동기, REST, Call By Value와 Call By Reference"
excerpt: "기술면접 준비"
categories: 
  - Study
tags: 
  - Interview
toc : true
---

## 동기와 비동기

**동기(Synchronous)** <br>

동기는 말 그대로 동시에 일어난다는 뜻이다. 직렬적으로 태스크(task)를 수행한다. 즉, 태스크는 순차적으로 실행되며 어떤 작업이 수행 중이면 다음 작업은 대기하게 된다.

<br><br> 

**비동기(Asynchronous)** <br>

비동기는 병렬적으로 태스크(task)가 수행된다. 즉, 태스크가 종료되지 않은 상태라 하더라도 대기하지 않고 다음 태스크를 실행한다. 서버에 데이터를 요청한 이후 서버로부터 응답될 때까지 대기하지 않고 즉시 다음 태스크를 수행한다. 이후 서버로부터 데이터가 응답되면 이벤트가 발생하고 이벤트 핸들러가 데이터를 가지고 수행할 태스크를 계속해 수행한다. 

<br><br>

**장단점** <br>
- 동기
    - 설계가 매우 간단하고 직관적
    - 결과가 주어질 때까지 아무것도 못하고 대기해야 한다.
- 비동기
    - 시간이 걸리더라도 다른 작업을 할 수 있으므로 자원을 효율적으로 사용
    - 동기보다 구현이 복잡함

<br><br>

-----

<br><br>


## REST

REST란 어떤 자원에 대해 CRUD 연산을 수행하기 위해 URI(Resource)로 요청을 보내는 것으로, Get, Post 등의 방식(Method)를 사용하여 요청을 보내며, 요청을 위한 자원은 특정한 형태로 표현된다. 그리고 이러한 REST 기반의 API를 웹으로 구현한 것이 RESTful API이다.

- REST의 특징
    - **Uniform Interface(일관된 인터페이스)** <br>
    Resource(URI)에 대한 요청이 통일되고, 한정적으로 수행하는 아키텍처 스타일을 의미한다. 이것은 요청하는 Client의 플랫폼에 무관하며, 특정 언어나 기술에 종속받지 않는 특징을 의미한다. 이러한 특징 덕분에 REST API는 HTTP를 사용하는 모든 플랫폼에서 요청이 가능하며, Loosely Coupling(느슨한 결합) 형태를 갖는다.
    - **Stateless(무상태성)** <br>
    서버는 각각의 요청을 별개의 것으로 인식하고 처리해야하며, 이전 요청이 다음 요청에 연관되어서는 안된다. 그래서 REST API는 세션 정보나 쿠키 정보를 활용하여 작업을 위한 상태 정보를 저장 및 관리하지 않는다. 이러한 무상태성 때문에 REST API는 서비스의 자유도가 높으며, 서버에서 불필요한 정보를 관리하지 않으므로 구현이 단순하다.
    - **Cacheable(캐시 가능)** <br>
    REST API는 결국 HTTP라는 기존의 웹 표준을 그대로 사용하기 때문에, 웹의 기존 인프라를 그대로 사용할 수 있다. 그러므로 REST API에서도 캐싱 기능을 적용할 수 있는데, HTTP 프로토콜 표준에서 사용하는 Last-Modified Tag 또는 E-Tag를 이용하여 캐싱을 구현할 수 있고, 이것은 대량의 요청을 효율적으로 처리할 수 있게 도와준다.
    - **Client-Server Architecture (서버-클라이언트 구조)** <br>
    REST API에서 자원을 가지고 있는 쪽이 서버, 자원을 요청하는 쪽이 클라이언트에 해당된다. 서버는 API를 제공하며, 클라이언트는 사용자 인증, Context(세션, 로그인 정보) 등을 직접 관리하는 등 역할을 확실히 구분시킴으로써 서로 간의 의존성을 줄인다.
    - **Self-Descriptiveness(자체 표현)** <br>
    REST API 요청 메세지만 보고도 이를 쉽게 이해할 수 있는 자체 표현 구조로 되어있다. 
    - **Layered System(계층 구조)** <br>
    REST API의 서버는 다중 계층으로 구성될 수 있으며 보안, 로드 밸런싱, 암호화 등을 위한 계층을 추가하여 구조를 변경할 수 있다. 또한 Proxy, Gateway와 같은 네트워크 기반의 중간 매체를 사용할 수 있게 해준다. 하지만 클라이언트는 서버와 직접 통신하는지, 중간 서버와 통신하는지 알 수 없다.


<br><br>

-----

<br><br>


## Call By Value와 Call By Reference


**Call By Value(값에 의한 호출)** <br>

Call by value는 인자로 받은 값을 복사하여 처리한다. 프로그래밍 구조상 Call by Value를 하면 값이 복사가 되기 때문에 `메모리량`이 늘어난다. 요즘에는 기기의 성능이 좋아져서 상관이 없다지만 많은 계산이 들어간다면 과부하의 원인이 된다. 하지만 복사하여 처리하기 때문에 원래의 값이 보존되어 안전하다.

<br><br> 

**Call By Reference(참조에 의한 호출)** <br>

Call By reference는 인자로 받은 값의 `주소`를 참조하여 직접 값에 영향을 준다. 복사하지 않고 직접 참조를 하기 때문에 속도가 빠르지만 직접 참조를 하기 때문에 원래의 값에 영향을 준다.