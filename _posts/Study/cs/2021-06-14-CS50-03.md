---
title: "[CS50] 배열"
excerpt: "컴파일링, 디버깅, 배열 등"
categories: 
  - Study
tags: 
  - CS
toc : true
---

<br>

<p align="center">
  <a href="https://www.boostcourse.org/cs112" target="_blank">
    <img src="https://user-images.githubusercontent.com/70805241/120475971-009abc80-c3e5-11eb-89d9-fbe289f41b73.png">
  </a>
</p>

<br>


> ## 컴파일링

```c
#include <stdio.h>

int main(void){
    printf("hello, world\n");
}
```

<br>

- main 함수는 프로그램의 시작점으로써 실행 버튼을 클릭하는 것과 같다.
- printf는 출력을 담당하는 함수이며 사용하기 위해서는 stdio.h 라이브러리가 필요하다.
- stdio.h는 헤더 파일로 C 언어로 작성되어 있으며 파일명이 .h로 끝나는 파일이다.
     - 이 파일에는 printf 함수의 프로토타입이 있어서 Clang 컴파일러가 프로그램을 컴파일할 때 printf가 무엇인지 알려주는 역할을 한다.
- 코드를 clang hello.c로 컴파일하고 ./a.out 명령으로 프로그램을 실행할 때 이 과정은 0과 1로 이루어진 파일 a.out을 생성하여 실행 가능하게 한다.

<br>

- a.out이 아닌 다른 파일명으로 컴파일하고 싶다면?
```
clang -o hello hello.c
```

- CS50 라이브러리를 사용한 프로그램을 컴파일 할 때는?
```c
clang -o hello hello.c -lcs50
```

이것은 clang에게 CS50 라이브러리에 있는 모든 0과 1들을 여기에 연결하라는 의미이다. <br>
더 간단히는 `make` 프로그램을 이용하면 이 모든 컴파일 과정을 자동으로 처리할 수 있다. <br>

make나 clang을 사용해서 프로그램을 실행할 때 아래 네 개의 단계를 거친다. 
- 전처리
- 컴파일링
- 어셈블링
- 링킹


<br><br>

### 전처리(Precompile)

- 컴파일의 전체 과정은 네 단계로 나누어볼 수 있다. 그 중 첫 번째 단계가 전처리이다.
- 전처리는 전처리기에 의해 수행된다.
- '#'으로 시작되는 C 소스코드는 전처리기에 실질적인 컴파일이 이루어지기 전에 무언가를 실행하라 알려준다.
- ex) `#include`는 전처리기에게 다른 파일의 내용을 포함시키라고 알려준다.

<br>

### 컴파일(Compile)

- 전처리기가 전처리한 소스 코드를 생성하고 나면 그 다음 단계는 컴파일이다.
- 컴파일러라고 불리는 프로그램은 C 코드를 **어셈블리어라는 저수준 프로그래밍 언어**로 컴파일한다.
- 어셈블리는 C보다 연산의 종류가 훨씬 적지만, 여러 연산들이 함께 사용되면 C에서 할 수 있는 모든 것들을 수행할 수 있다.
- C 코드를 어셈블리 코드로 변환시켜줌으로써 컴파일러는 컴퓨터가 이해할 수 있는 언어와 최대한 가까운 프로그램으로 만들어준다.
- 컴파일이란 용어는 소스 코드에서 오브젝트 코드로 변환하는 전체 과정을 통틀어 일컫기도 하지만, 구체적으로 전처리한 소스 코드를 어셈블리 코드로 변환시키는 단계를 말하기도 한다.

<br>

### 어셈블(Assemble)

- 어셈블 단계는 **어셈블리 코드를 오브젝트 코드**로 변환시킨다. 
- 컴퓨터의 중앙처리장치가 프로그램을 어떻게 수행해야 하는지 알 수 있는 명령어 형태인 **연속된 0과 1들로 바꿔주는 작업**
- 이 변환작업은 어셈블러라는 프로그램이 수행한다. 소스 코드에서 오브젝트 코드로 컴파일 되어야 할 파일이 딱 한 개라면, 컴파일 작업은 여기서 끝이 난다. 그렇지 않은 경우는 다음 단계인 링크라 불리는 단계가 추가된다.

<br>

### 링크(Link)

- 만약 프로그램이 **여러 개의 파일로 이루어져 있어 하나의 오브젝트 파일로 합쳐져야 한다면** `링크`라는 컴파일의 마지막 단계가 필요하다.
- 링커는 여러 개의 다른 오브젝트 코드 파일을 실행 가능한 하나의 오브젝트 코드 파일로 합쳐준다.


<br>

이 네 단계를 거치면 최종적으로 실행 가능한 파일이 완성된다. <br>


<br>

---------

<br>


> ## 디버깅


### 버그와 디버깅

- `버그`(bug)는 코드에 들어있는 오류
- 버그로 인해 프로그램의 실행에 실패하거나 프로그래머가 원하는 대로 동작하지 않게 된다.
- `디버깅`(debugging)은 코드에 있는 버그를 식별하고 고치는 과정이다.
- 프로그래머는 디버거라고 불리는 프로그램을 사용하여 디버깅을 하게 된다.

<br><br>

### 디버깅의 기본

- 디버거는 프로그램을 특정 행에서 멈출 수 있게 해주기 때문에 버그를 찾는데 도움이 된다.
- 프로그래머는 멈춰진 그 지점에서 무슨 일이 일어나는지 볼 수 있다.
- 프로그램이 멈추는 특정 지점을 `중지점`이라 한다.
- 프로그러매가 프로그램을 한번에 한 행씩 실행할 수 있게 해준다.


<br><br>

### help50

```c
int main(void)
{
    printf("hello, world\n");
}
```

- make 프로그램을 이용하여 컴파일해보면 "implicitly declaring library function 'printf'"라는 에러 메세지가 나타난다.
- 이런 메세지를 이해하기 힘들 때 help50 프로그램을 사용하면 좋다.
- make 앞에 help50을 붙여 실행하면 다시 컴파일시 생기는 오류를 해석해준다.
```
help50 make 파일이름
```

<br><br>

### printf

```c
#include <stdio.h>

int main(void)
{
    for (int i = 0; i <= 10; i++)
    {
        printf("#\n");
    }
}
```

- 이 코드를 실행하면 에러는 발생하지 않지만 의도와는 다르게 '#'이 11개나 출력된다.
- 디버깅의 다른 방법으로는 직접 의심이 가는 변수를 출력해서 확인해 볼 수 있다.

<br>

```c
#include <stdio.h>

int main(void)
{
    for (int i = 0; i <= 10; i++)
    {
        printf("i is now %i: ", i);
        printf("#\n");
    }
}
```

- i가 0에서 시작하기 때문에 for 루프의 i <= 10 이라는 조건은 실제로 11번 만족한다는 사실을 알 수 있다.
- 따라서 i < 10으로 수정해주면 '#'이 10번 출력된다.


<br><br>

### debug50

- CS50 IDE를 사용하면 debug50이라는 프로그램을 사용할 수 있다.
- 소스 코드에 직접 브레이크포인트를 저장하고 소스파일을 컴파일한 후에 **dubug50 파일명**으로 실행한다. <br> ![debug50](https://user-images.githubusercontent.com/70805241/122044612-aa337200-ce17-11eb-92f2-792ac7ba5a31.png)

- 디버깅 종료를 위해 **Ctrl + c**를 누르면 된다.