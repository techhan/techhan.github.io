---
title: "2020년 11월 13일"
excerpt: "IO, JDBC"
search: true
categories: 
  - Academy
tags: 
  - JAVA
  - TIL
  - JDBC
toc: true
---

## IO(입출력)
### Stream(스트림) 클래스
입출력 장치에서 데이터를 읽고 쓰기 위해서 자바에서 제공하는 클래스이다. 모든 스트림은 `단방향`이며 각각의 장치마다 연결할 수 있는 스트림이 존재한다. 하나의 스트림으로 입출력을 동시에 수행할 수 없으므로 동시에 수행하려면 2개의 스트림이 필요하다.
{: .notice--success}

```java
//IORun.java

package com.kh.io.run;

import com.kh.io.view.IOView;

public class IORun {
	public static void main(String[] args) {
		new IOView().displayMain();
        //displayMain() 호출
	}
}
```
<br/>

```java
//IOView.java

package com.kh.io.view;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.InputMismatchException;
import java.util.Scanner;

import com.kh.io.model.service.ByteService;
import com.kh.io.model.service.CharService;

public class IOView {
    private Scanner sc = new Scanner(System.in);
    private ByteService bService = new ByteService();
    private CharService cService = new CharService();

    public void displayMain() {
        int sel = 0;

        do {
            try {
				System.out.println("==== 입출력 메뉴 ====");
				System.out.println("1. BYTE 기반 파일 작성(출력)");
				System.out.println("2. BYTE 기반 파일 열기(입력)");
				System.out.println("3. 문자 기반 파일 열기(출력)");
				System.out.println("4. 문자 기반 파일 열기(입력)");
				System.out.println("0. 종료");
				System.out.print("메뉴 선택>>> ");

				sel = sc.nextInt();
				sc.nextLine(); // 이후 동작에서 문자를 입력받을 수 있기 때문에 미리 개행문자 제거

				switch(sel) {
				case 1 : byteFileSave(); break;
				case 2 : byteFileOpen(); break;
				case 3 : charFileSave(); break;
				case 4 : charFileOpen(); break;
				case 0 : System.out.println("프로그램 종료");  break;
				default : System.out.println("잘못 입력함.");
				}
			}catch(InputMismatchException e){
				System.out.println("정수만 입력해주세요.");
				sel = -1; // sel이 0으로 유지돼서 종료되는걸 방지
				sc.nextLine(); //입력 버퍼에 남아있는 잘못 입력한 문자열을 제거
			}catch(Exception e) {
				e.printStackTrace();
			}
        } while (sel != 0);
    }

}

public void byteFileSave() throws FileNotFoundException {
    System.out.println("---- 바이트 기반 파일 입력 ----");
    System.out.println("새로 생성할 파일명 : ");
    String fileName = sc.nextLine();

    StringBuffer content = new StringBuffer();

    // 입력되는 내용 한 줄 임시 저장할 변수
    String input = null;

    System.out.println("----- 파일 내용 출력(exit 입력 시 종료) -----");

    while(true) {
      input = sc.nextLine();

      // 입력받은 문자열이 "exit"인 경우 반복문 종료
      if(input.equals("exit")) break;

      //StringBuffer에 입력받은 내용 + 개행문자를 추가
      conent.append(input + "\n");
    }

    int result = bService.byteFileSave(fileName, content.toString());
    if (result == 1){
      System.out.println(fileName + ".txt 파일 저장 성공");
    } else {
      System.out.println(fileName + ".txt 파일 저장 실패");
    }
}
```
<br/>

```java
// ByteService.java

package com.kh.io.model.service;

import java.io.File;
import java.io.FileNotFoundException;

import com.kh.io.model.dao.ByteDAO;

public class ByteService {
	private ByteDAO byteDAO = new ByteDAO();


public int byteFileSave(String fileName, String content) throws FileNotFoundException {
		File folder  = new File("byte");

    // byte 폴더가 존재하지 않을 경우 byte 폴더 생성
    if(!folder.exists()) {
      folder.mkdir();
    }

    int result = byteDAO.byteFileSave(fileName, content, "byte");

    return result; //byteDAO.byteFileSave()의 수행 결과를 그대로 View로 반환한다.
  }

public String byteFileOpen(String path) throws FileNotFoundException {
    // Service는 DAO로 전달할 데이터 또는 반환받은 데이터를 가공하는 역할(비즈니스 로직)

    String content = byteDAO.byteFileOpen(path);
    return content;
  }
}
```
```java
// CharService.java
package com.kh.io.model.service;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;

import com.kh.io.model.dao.CharDAO;

public class CharService {
	  private CharDAO charDAO = new CharDAO();

    public int charFileSave(String fileName, String content)  throws IOException {
        File folder = new File("char");

        if(!folder.exists()) {
          folder.mkdir();
        }

        int result = charDAO.charFileSave(fileName, content, "char");

        return result;
}

public String charFileOpen(String path) throws FileNotFoundException {
    return charDAO.charFileOpen(path);
}
```

<br/>


```java
// ByteDAO.java

package com.kh.io.model.dao;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;

public class ByteDAO {
	  // DAO(Data Access Object)
    // - 데이터 저장소에 접속하여 실제 데이터를 전송하거나 결과 값을 전달받는 역할을 하는 객체

    // 바이트 기반 스트림 : 1byte 단위로 데이터를 입력 또는 출력하는 스트림
    public int byteFileSave(String fileName, String content, String path) throws FileNotFoundException{
      int result = 0;

      // 프로그램 -> 파일로 출력
      // FileOutputStream 사용

      //byte 폴더 안에 입력받은 파일명.txt 파일을 출력할 스트림 객체 생성
      FileOutputStream fOut = new FileOutputStream(path + "/" + fileName + ".txt");

      // FileOutputStream 객체 생성 성공 시 
      // 매개변수로 작성된 파일이 없다면 -> 바로 생성
      // 있다면 -> 덮어쓰기 또는 이어쓰기
      // --> 매개변수에 'true' 작성 시 이어쓰기, false 또는 생략 시 덮어쓰기

      try {
        for(int i = 0; i < content.length(); i++) {
          //content에 작성된 문자의 개수만큼 반복하며
          //한 글자씩 스트림을 통해 파일로 출력한다.

          fOut.write(content.charAt(i));
        }

        result = 1; // 1 반환 시 출력 성공
      }catch(IOException e) {
        e.printStackTrace();
      } finally {
        // 스트림은 사용한 경우 반드시 반환해야 한다.
        try {
          if(fOut != null)  fOut.close();
        }catch(IOException e){
          e.printStackTrace();
        }
      }
      return result;
    }

    public String byteFileOpen(String path) throws FileNotFoundException {
		
		StringBuffer sb = null; // 읽어온 파일 내용을 저장할 변수

    FileInputStream fis = new FileInputStream(path);
    //FileInputStream 객체 생성 시
    //매개변수에 작성된 path에 있는 파일과 연결한다.
    //만약 해당 파일이 없다면 FileNotFoundException 발생

    //바이트 기반 스트림의 read() 메소드는
    //파일의 내용을 순차적으로 1바이트씩 읽어온다.
    //더 이상 읽어올 내용이 없다면 -1을 반환한다.

    try {
      sb = new StringBuffer();

      int value = 0; // read()를 통해 읽어올 값을 임시 저장할 변수
      // int형 변수를 사용하는 이유? 한 글자씩(char)로 읽어오기 때문에 int형으로도 가능

      while( (value = fis.read()) != -1) {
        //while문을 이용해서 read() 메소드가 -1이 나올 때까지 반복함

        //읽어온 값 value를 char 형태로 형변환하여 sb에 누적
        sb.append((char)value);
      }
    }catch(IOException e) {
      e.printStackTrace();
    }finally {
      try {
        if(fis != null) fis.close();
      }catch(IOException e) {
        e.printStackTrace();
      }
    }

    if(sb != null) return sb.toString();
    else return null;
    }
}
```

```java
// CharDAO.java

package com.kh.io.model.dao;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

public class CharDAO {
	
	  // 문자 기반 스트림 : 2byte 문자 단위(유니코드)로 데이터를 입력 또는 출력하는 스트림
    // 프로그램 -> 파일로 content 출력

    public int charFileSave(String fileName, String content, String path) throws IOException {
        int result = 0;
        FileWriter fw = new FileWriter(path + "/" + fileName + ".txt");

        try {
            fw.write(content);
            // 문자 기반 스트림은 문자만 가지고 있는 데이터를 송수신하는 용도
            // 문자 기반 스트림의 write() 메소드는 모든 문자를 순서대로 내보내도록 내부적으로
            // 구현되어있다.

            result = 1;
        } catch(IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if(fw != null) fw.close();
            } catch(IOException e){
                e.printStackTrace();
            }
        }

        return result;
    }

    // 파일 -> 프로그램으로 입력
    public String charFileOpen(String path) throws FileNotFoundException {
		    StringBuffer sb = null;
        FileReader fr = new FileReader(path);

        try {
            sb = new StringBuffer();

            //FileReader의 read() 메소드는 한 글자씩만 읽어온다.
            //더 이상 읽을 내용이 없다면 -1을 반환한다.

            int value = 0;
            while( (value = fr.read()) != -1) {
                sb.append((char)value);
            }
        } catch(Exception e) {
            e.printStackTrace();
        } finally {
            try {
                if(fr != null) fr.close();
            }catch(Exception e) {
                e.printStackTrace();
            }
        }

        if(sb != null) return sb.toString();
        else return null;
    }
}
```
<br/>
